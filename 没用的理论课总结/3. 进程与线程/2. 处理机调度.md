# 2. 处理机调度

## 2.1 调度的概念

### 2.1.1 调度的基本概念

处理机调度是对处理机进行分配，即从就绪队列中按照一定的算法（公平、高效的原则）选择一个进程并将处理机分配给它运行。

### 2.1.2 调度的层次

一个作业从提交开始到完成，通常经历三级调度：

- 高级调度（宏观调度、作业调度）：选择一个作业执行。
- 中级调度（内存调度、内外存交换）：将暂时不能运行的进程调至外存等待，当其具备运行条件且内存有空闲时再调回内存。目的在于提高内存利用率和系统吞吐量。
- 低级调度（进程调度、微观调度）：按照一定的算法从就绪队列中选择一个进程并将处理机分配给它运行。

进程调度是最基本的，不可或缺。

## 2.2 进程调度的分类

1. 根据是否在时钟中断作出调度决策
	- **非抢占式**：时钟中断时不会做调度决策，被调度进程会一直执行直到阻塞或主动放弃CPU，不会强迫进程挂起
	- **抢占式**：时钟中断时做调度决策。被调度程序运行一个固定的最大时间段，如果时间结束进程还在执行，挂起进程，切换。
2. 根据不同的应用领域，优化目标不同
	- **批处理系统**：通常采用非抢占式算法或分配长时间周期的抢占算法。
	- **交互式系统**：通常采用抢占式算法。
	- **实时系统**：抢占式为主，也可能非抢占式。

## 2.3 调度的目标

对于不同的系统，调度算法的评价标准不同。

### 2.3.1 批处理系统

- **吞吐量**：单位时间内 CPU 完成作业的数量。
- **周转时间**：
	- 周转时间：作业从提交到完成所经历的时间。$周转时间 = 作业完成时间 - 作业提交时间$
	- 平均周转时间：多个作业周转时间的平均值。$平均周转时间 = (作业1的周转时间 +\dots+ 作业n的周转时间)\div n$
	- 带权周转时间：作业周转时间与作业实际运行时间的比值。$带权周转时间=\frac{周转时间}{实际运行时间}$
	- 平均带权周转时间：多个作业带权周转时间的平均值。$平均周转时间 = (作业1的带权周转时间+\dots+作业n的带权周转时间)\div n$
- **CPU 利用率**：$CPU利用率=\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}$

吞吐量和周转时间不一定负相关的。例如，总是优先运行短作业的调度程序：吞度量很大，但是长作业周转时间很长。

### 2.3.2 交互式系统

- **响应时间**：用户提交请求到系统首次产生响应所用的时间。

交互式系统应满足：

- **最小化响应时间**：交互式系统应该首先满足交互式请求。
- **等比例变化**：任务花费时间随着其复杂度应该线性增长。

### 2.3.3 实时系统

- **满足截止时间**：满足所有或者大多数应用的截止时间。
- **可预测性**：保证可预测性和规律性

## 2.4 调度算法

### 2.4.1 批处理系统

#### (1) 先来先服务（FCFS）

按先后顺序调度，既可用于作业调度，也可用于进程调度。

- 按照作业提交或进程变为就绪状态的先后次序进入就绪队列排队，按队列次序分派CPU
- 当前作业或进程占用CPU，直到执行完或阻塞，
	才出让CPU（非抢占）。
- 在作业或进程唤醒后（如I/O完成），放到就绪队列尾部。

特点：

- 公平，容易理解和实现。
- 有利于长作业（但会导致吞吐量受限）。
- 有利于计算密集型作业，不利于I/O密集型作业。

#### (2) 短作业优先（SJF）

又称短进程优先算法。对预期执行时间短的作业（进程）优先分派处理机。后来的短作业不抢占正在执行的作业。

优点：

- 比 FCFS 改善平均周转时间和平均带权周转时间
	，缩短作业的等待时间。
- 当作业同时可运行条件下，周转时间最优。
- 提高系统的吞吐量。

缺点：

- 对长作业非常不利，可能长时间得不到执行。
- 难以准确估计作业（进程）的执行时间。
- 如果正在执行进程很慢，新来的短作业无法执行。

#### (3) 最短剩余时间优先（SRTN）

将短作业优先进行改进，
改进为抢占式。

当一个新就绪的进程到达时，如果它比当前运行进程具有更短的完成时间，系统抢占当前进程，选择新就绪的进程执行。

缺点：源源不断的短任务到来，可能使长的任务长
时间得不到运行，导致产生“饥饿”现象。

#### (4) 最高响应比优先（HRRN）

FCFS 算法和 SJF
算法的折衷，主要用于作业调度。既考虑作业的运行时间，又考虑作业的等待时间。照顾短作业的同时又避免饿死长作业。

每次进行调度时，先计算后备作业队列每个作业的响应比，然后响应比最大的作业运行

响应比计算公式为：$响应比R_p=\frac{已等待时间+要求服务时间}{要求服务时间}$

特点：

- 短作业容易得到较高的响应比
- 长作业等待时间足够长后，也将获得足够高的响应比
- 饥饿现象不会发生

缺点：每次计算各道作业的响应比会有一定的时间开销，性能比 SJF 略差。

### 2.4.2 交互式系统

#### (1) 时间片轮转

- 将系统中所有的就绪进程按照 FCFS 原则，排成一个队列。
- 每次调度时将CPU分派给队首进程，让其执行一个时间片。时间片的长度从几个ms到几百ms。
- 如果进程在时间片结束前阻塞或者结束，会立刻进行CPU切换。
- 在一个时间片结束时，发生时钟中断（抢占式）。
- 如果时钟中断发生时进程还在运行，将其送到就绪队列的末尾，并通过上下文切换执行当前的队首进程。

#### (2) 优先级调度

优先级调度赋予每个进程不同优先级，高优先级先运行。

可以静态或者动态赋予进程优先级；可以采用抢占式也可采用非抢占式方法调度。

一般而言，优先级分配原则：

- 系统进程＞用户进程
- 交互型进程＞非交互型进程
- I/O型进程＞计算型进程

#### (3) 多级队列调度

引入多个就绪队列，通过各队列的区别对待，达到一个综合的调度目标。

- 根据作业或进程的性质或类型的不同，分配到不同就绪队列。
- 每个作业固定归入一个队列。

不同队列可有不同的优先级、时间片长度、调度策略等；在运行过程中还可改变进程所在队
列。

#### (4) 多级反馈队列调度

- 设置多个就绪队列，分别赋予不同的优先级（如逐级降低），队列1的优先级最高。每个队列执行时间片的长度也不同，规定优先级越低则时间片越长（如逐级加倍）。
- 新进程进入内存后，先投入队列1的末尾，按FCFS算法调度；若按队列1一个时间片未能执行完，则降低投入到队列2的末尾，同样按  FCFS 算法调度；如此下去，降低到最后的队列，则按“时间片轮转“算法调度直到完成。
- 仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾。

#### (5) 彩票调度

将 CPU 资源的使用权发以彩票的形式发给进程，每次进行随机抽奖，中奖的进程得到资源。

通过设定一个进程得到彩票数的比例，可以控制其得到系统资源的概率。

### 2.4.3 优先级倒置

优先级倒置是指高优先级进程（或线程）被低优先级进程（或线
程）延迟或阻塞。

解决方法：

- 优先级置顶
- 优先级继承

### 2.4.4 实时系统

实时系统是一种时间起着主导作用的系统。当外部的一种或多种物理设备给了计算机一个刺激，
而计算机必须在一个确定的时间范围内恰当地做出反应。

实时系统被分为硬实时系统和软实时系统。硬实时要求绝对满足截止时间要求（如：汽车和飞机的控制系统），而软实时倒是可以偶尔不满足（
如：视频/音频程序）。

#### (1) 实时调度

实时调度：多个互相竞争的进程，若干进程或全部进程具有必须满足的最终时限的调度。

问题描述：

假设一任务集 $S=\{t_1,t_2,t_3,\dots, t_n\}$，周期分别是 $T_1,T_2,\dots,T_n$，
执行时间为 $c_1,c_2,\dots,c_n$，截止周期为$D_1,D_2,\dots, D_n$，通常 $D_i = T_i$。CPU 利用率：用 $U=\sum_1^n(c_i/T_i)$ 表示。**CPU 利用率大于 1 时不可能实现实时调度！**

前提条件：

- 任务集（S）是已知的；
- 所有任务都是周期性（T）的，必须在限定的时限（D）内完成；
- 任务之间都是独立的，每个任务不依赖于其他任务；
- 每个任务的运行时间（c）是不变的；
- 调度，任务切换的时间忽略不计。

#### (2) 静态表调度

通过对所有周期性任务的分析预测（到达时间
、运行时间、结束时间、任务间的优先关系）
，事先确定一个固定的调度方案。

特点：

- 无任何动态计算，按固定方案进行，开销最小；
- 无灵活性，只适用于完全固定的任务场景。

#### (3) 单调速率调度（RMS）

算法内容：

- 任务的周期越小，频率(速率)越高，其优先级越高，
	优先级最高的任务最先被调度。
- 如果两个任务的优先级一样，当调度它们时，RMS
	算法将随机选择一个调度。

RMS是单处理器下的最优静态调度算法。

缺点：CPU 利用率高时会失效。

#### (4) 最早截止时间优先算法（EDF）

算法内容：

- 任务的绝对截止时间越早，其优先级越高，优先级最高的任务最先被调度。
- 如果两个任务的优先级一样，当调度它们时，EDF算法将随机选择一个调度。
- 调度时机：任务本周期执行完毕、新任务到来（
	按照周期）

### 2.4.5 多处理机调度

与单处理机调度的区别：

- 注重整体运行效率（而不是个别处理机的利用率）；
- 更多样的调度算法；
- 多处理机访问OS数据结构时的互斥（对于共享内存系统）。

调度单位广泛采用线程。

#### (1) 非对称式多处理系统(AMP)

AMP 指多处理器系统中各个处理器的地位不同。

如：主－从处理机系统，由主处理机管理一个公共就绪队列，并分派进程给从处理机执行。

各个处理机有固定分工，如一个处理机执行
OS的系统功能，另一个处理I/O。

#### (2) 对称式多处理系统(SMP)

SMP 指多处理器系统中，各个处理器的地位相同。

按控制方式，SMP调度算法可分为集中控制和分散控制。下面的静态和动态调度都是集中控制，而自调度是分散控制。

#### (3) 多处理机调度算法

##### 1. 静态分配

每个CPU设立一个就绪队列，进程从开始执行到完成，都在同一个
CPU上。

优点：调度算法开销小。

缺点：难以准确预测执行时间，容易出现忙闲不
均。

##### 2. 动态分配

各个 CPU 采用一个公共就绪队列，队首进程每次分派到当前空闲的CPU上执行。可防止系统中多个处理器忙闲不均。

##### 3. 自调度

各个CPU采用一个公共就绪队列，每个处理机都可以从队列中选择适当进程来执行。需要对就绪队列的数据结构进行互斥访问控制。是最常用的算法，实现时易于移植。

各个处理机自行在就绪队列中取任务。

优点：不需要专门的处理机从事任务分派工作。

缺点：当处理机个数较多（如十几个或上百个）
时，对就绪队列的访问可能成为系统的瓶颈。

##### 4. 成组调度

为了解决自调度方式中线程频繁切换的问题。

将一个进程中的一组线程，每次分派时同时到一组处理机上执行，在剥夺处理机时也同时对这一组线程进行。

优点：

- 通常这样的一组线程在应用逻辑上相互合作，成组调度提高了这些线程的执行并行度，有利于减少阻塞和加快推进速度，最终提高系统吞吐量。
- 每次调度可以完成多个线程的分派，在系统内线程总数相同时能够减少调度次数，从而减少调度算法的开销。

##### 5. 专用处理机调度

在一个应用程序的执行期间，专为该应用程序分配一组处理器，每一个线程一个处理器。

这种方式很浪费。但仍有利用市场，适用于并发程度相当高的多处理机环境。

## 2.3 上下文切换

切换 CPU 到另一个进程需要保存当前进程状态并恢复另一个进程的状态，这一过程称为上下文切换。

上下文是指某一时刻 CPU 寄存器和程序计数器的内容。

进行上下文切换时，内核会将旧进程状态保存在其 PCB 中，然后加载经调度而要执行的新进程的上下文。

上下文切换的流程如下：

- 挂起一个进程，保存处理器的上下文，包括程序计数器和其它寄存器；保存内存镜像（页表信息）。
- 用新状态和其它相关信息更新正在运行进程的 PCB。
- 把进程移至合适的队列——就绪或阻塞队列。
- 选择另一个要执行的进程，更新进程的 PCB。
- 从被选中进程中重装入 CPU 上下文和内存镜像。
- 转为用户态，恢复进程的执行