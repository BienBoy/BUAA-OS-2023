<h1 align="center">Lab2实验报告</h1>

## 思考题

### Thinking2.1

均为虚拟地址。

### Thinking2.2

#### (1)

使用宏来实现链表，可间接实现泛型编程，减少重复代码的编写。

#### (2)

单向链表没有insert_before功能，insert_after需要对两个指针操作，复杂度O(1)；remove时，需先遍历链表至前一结点，再进行remove，复杂度为O(n)

双向链表insert_before、insert_after均需对四个指针操作，remove需处理两个指针，复杂度均为O(1)。

循环链表insert_before、insert_after均需对四个指针操作，remove需处理两个指针，需要对head结点特殊处理，复杂度均为O(1)。

### Thinking2.3

C

### Thinking2.4

不同进程可能使用相同的虚拟地址，通过使用ASID，可以区分不同进程间的虚拟地址。

64

### Thinking2.5

tlb_invalidate调用tlb_out

将TLB中指定表项通过清零的方式设为无效

```assembly
#include <asm/asm.h>

LEAF(tlb_out)						/*定义在asm/asm.h中的宏，用于定义叶函数*/
.set noreorder						/*不允许汇编器对指令进行重新排序*/
	mfc0    t0, CP0_ENTRYHI			/*将EntryHi寄存器内容存入t0，一边函数调用结束时恢复其值*/
	mtc0    a0, CP0_ENTRYHI			/*将a0寄存器内容即key值存入EntryHi*/
	nop								/*tlbp指令的前后各插入一个nop以解决数据冒险*/
	tlbp							/*根据EntryHi中的Key（包含VPN与ASID），查找TLB中与之对应的表项，并将
表项的索引存入Index寄存器*/
	nop								/*tlbp指令的前后各插入一个nop以解决数据冒险*/
	mfc0    t1, CP0_INDEX			/*将要清除的表项索引存入寄存器t1*/
.set reorder						/*允许汇编器对指令进行重新排序*/
	bltz    t1, NO_SUCH_ENTRY		/*判断TLB中是否含该表项，若TLB中不含该表项，则无需清除直接退出*/
.set noreorder						/*不允许汇编器对指令进行重新排序*/
	mtc0    zero, CP0_ENTRYHI		/*将EntryHi寄存器置零*/
	mtc0    zero, CP0_ENTRYLO0		/*将EntryLo寄存器置零*/
	nop								/*插入一个nop以解决数据冒险*/
	tlbwi							/*将EntryHi寄存器和EntryLo寄存器内容写入目标表项，实现置零*/
.set reorder						/*允许汇编器对指令进行重新排序*/

NO_SUCH_ENTRY:
	mtc0    t0, CP0_ENTRYHI			/*将t0寄存器内容存入EntryHi使其恢复函数调用前的状态*/
	j       ra						/*返回调用函数处*/
END(tlb_out)						/*定义在asm/asm.h中的宏，用于结束函数的定义*/
```

### ThinkingA.1

三级页表页目录的基地址：$PT_{base}|(PT_{base} >> 9)|(PT_{base}>>18)$

映射到页目录自身的页目录项（自映射）：$PT_{base}|(PT_{base} >> 9)|(PT_{base}>>18)|(PT_{base}>>27)$

### Thinking2.6

x86架构下的分段和分页机制共同实现了内存管理逻辑。

>**分段机制**
>
>分段是一种朴素的内存管理机制，它将内存划分成以起始地址 base 和长度 limit 描述的块，这些内存块就称为段。段可以与程序最基本的元素联系起来。例如程序可以简单地分为代码段、数据段和栈，段机制中就有对应的代码段、数据段和栈段。
>
>分段机制由 4 个基本部分构成：逻辑地址、段选择寄存器、段描述符和段描述符表。其核心思想是：使用段描述符描述段的基地址、长度以及各种属性。当程序使用逻辑地址访问内存的某个部分时，CPU 通过逻辑地址中的段选择符索引段描述符表以得到该内存对应的段描述符。并检验程序的访问是否合法，如合法，根据段描述符中的基地址将逻辑地址转换为线性地址。
>
>**分页机制**
>
>X86 的分页机制是更加粒度化的内存管理机制，与分段机制将内存划分成以基地址和长度描述的多个段进行管理不同，分页机制是用粒度化的单位页来管理线性地址空间和物理地址空间。X86 架构下一个典型的页大小是 4KB，则一个 4GB的虚拟地址空间可以划分成 1024x1024 个页面。物理地址空间划分同理。x86 架构允许大于 4KB 的页面大小，这里只介绍 4KB 的页面管理机制。
>
>分页机制让现代操作系统中的虚拟内存机制成为可能，感谢这种机制，一个页面可以存在于物理内存中，也可以存放在磁盘的交换区域中。程序可以使用比物理内存更大的内存区域。分页机制的核心思想是通过页表将线性地址转换成为物理地址，并配合旁路转换缓冲区来加速地址转换过程。操作系统在启动过程中，通过将 CR0 寄存器的 PG 位置 1 来启动分页机制。分页机制主要由页表、CR3 寄存器和 TLB 三个部件构成。
>
>页表 Page Table 是用于将线性地址转换成物理地址的主要数据结构。一个地址对齐到页边界后的值称为页帧号，它实际是该地址所在页面的基地址。线性地址对应的也帧号即虚拟页帧号 VFN，物理地址对应的页帧号即物理地址页帧号 PFN 或机器页帧号。故也可以认为，页表是存储 VFN 到 PFN 映射的数据结构。4KB 大小的页面使用两级页表。
>
>页目录项 PageDirectoryEntry 包含页表的物理地址。页目录项存放在页目录中。CPU 使用线性地址的 22-31 位索引页目录，以获得该线性地址对应的页目录项。每个页目录项为 4B 大小，故页目录占用一个 4KB 大小的物理页面，共包含 1024 的页目录项。
>
>页表项 PageTableEntry 页表项包含该线性地址对应的 PFN。页表项存放在页表中。CPU 使用 12-21 位索引页表，获得该线性地址对应的页表项。通过将线性地址的 0-11 位偏移量和基地址相加，就可以得到线性地址对应的物理地址。页表项为 4B 大小，故页表包含 1024 个页表项，占用一个 4KB 页面。

以上内容来自：[X86内存管理机制--分段机制详析_描述分段内存管理机制。](https://blog.csdn.net/d1306937299/article/details/87874422)和[x86内存管理机制--分页机制详析](https://blog.csdn.net/d1306937299/article/details/87981860)

x86采用分段和分页机制共同实现内存管理逻辑，分段的方式有利于实现共享。

## 难点

### 1. 链表宏

在`include/queue.h`中定义了链表宏用于实现链表。该链表宏实现的是一个双向链表，但不同于数据结构中所学的双向链表，其指针一个指向下一元素，另一指针指向前一元素的next指针。因此，该链表不能双向遍历，只能前向遍历，设置双指针只为便于在某一元素前面添加新元素或删除某一元素。

### 2. 虚拟地址转换

实验中，采用两级页表。通过page_lookup函数，可获取虚拟地址所对应的页。

在page_lookup转换过程中，先调用pgdir_walk函数获取二级页表项的物理地址，然后判断是否有效，有效则通过pa2page转换为对应页的地址。

## 感想

这次实验难度较大，通过对空闲页建立一个双向链表实现了页的管理；同时编写了一些函数实现了虚拟地址至页地址的转换。

实验过程中，对不同地址，较难区分，虚拟地址、内核虚拟地址、物理地址、页地址等概念常常混淆。完成实验后，对这些概念有了进一步的了解，但还是比较懵。
